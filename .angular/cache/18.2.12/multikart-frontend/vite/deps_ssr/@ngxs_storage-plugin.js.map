{
  "version": 3,
  "sources": ["../../../../../../node_modules/@ngxs/storage-plugin/fesm2015/ngxs-storage-plugin.js"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Injector, NgModule, inject } from '@angular/core';\nimport { StateToken, actionMatcher, InitState, UpdateState, getValue, setValue, NGXS_PLUGINS } from '@ngxs/store';\nimport { isPlatformServer, isPlatformBrowser } from '@angular/common';\nimport { tap } from 'rxjs/operators';\nconst NG_DEV_MODE$4 = typeof ngDevMode === 'undefined' || ngDevMode;\nconst NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken(NG_DEV_MODE$4 ? 'NGXS_STORAGE_PLUGIN_OPTIONS' : '');\nconst STORAGE_ENGINE = new InjectionToken(NG_DEV_MODE$4 ? 'STORAGE_ENGINE' : '');\n\n/**\n * The following key is used to store the entire serialized\n * state when there's no specific state provided.\n */\nconst DEFAULT_STATE_KEY = '@@STATE';\nfunction storageOptionsFactory(options) {\n  return Object.assign({\n    key: [DEFAULT_STATE_KEY],\n    storage: 0 /* LocalStorage */,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    beforeSerialize: obj => obj,\n    afterDeserialize: obj => obj\n  }, options);\n}\nfunction engineFactory(options, platformId) {\n  if (isPlatformServer(platformId)) {\n    return null;\n  }\n  if (options.storage === 0 /* LocalStorage */) {\n    return localStorage;\n  } else if (options.storage === 1 /* SessionStorage */) {\n    return sessionStorage;\n  }\n  return null;\n}\nfunction getStorageKey(key, options) {\n  // Prepends the `namespace` option to any key if it's been provided by a user.\n  // So `@@STATE` becomes `my-app:@@STATE`.\n  return options && options.namespace ? `${options.namespace}:${key}` : key;\n}\n\n/** Determines whether the provided key has the following structure. */\nfunction isKeyWithExplicitEngine(key) {\n  return key != null && !!key.engine;\n}\n/** This symbol is used to store the metadata on state classes. */\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nfunction exctractStringKey(storageKey) {\n  // Extract the actual key out of the `{ key, engine }` structure.\n  if (isKeyWithExplicitEngine(storageKey)) {\n    storageKey = storageKey.key;\n  }\n  // Given the `storageKey` is a class, for instance, `AuthState`.\n  // We should retrieve its metadata and the `name` property.\n  // The `name` property might be a string (state name) or a state token.\n  if (storageKey.hasOwnProperty(META_OPTIONS_KEY)) {\n    storageKey = storageKey[META_OPTIONS_KEY].name;\n  }\n  return storageKey instanceof StateToken ? storageKey.getName() : storageKey;\n}\nconst NG_DEV_MODE$3 = typeof ngDevMode === 'undefined' || ngDevMode;\nconst FINAL_NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken(NG_DEV_MODE$3 ? 'FINAL_NGXS_STORAGE_PLUGIN_OPTIONS' : '');\nfunction createFinalStoragePluginOptions(injector, options) {\n  const storageKeys = Array.isArray(options.key) ? options.key : [options.key];\n  const keysWithEngines = storageKeys.map(storageKey => {\n    const key = exctractStringKey(storageKey);\n    const engine = isKeyWithExplicitEngine(storageKey) ? injector.get(storageKey.engine) : injector.get(STORAGE_ENGINE);\n    return {\n      key,\n      engine\n    };\n  });\n  return Object.assign(Object.assign({}, options), {\n    keysWithEngines\n  });\n}\nconst NG_DEV_MODE$2 = typeof ngDevMode === 'undefined' || ngDevMode;\nclass NgxsStoragePlugin {\n  constructor(_options, _platformId) {\n    this._options = _options;\n    this._platformId = _platformId;\n    this._keysWithEngines = this._options.keysWithEngines;\n    // We default to `[DEFAULT_STATE_KEY]` if the user explicitly does not provide the `key` option.\n    this._usesDefaultStateKey = this._keysWithEngines.length === 1 && this._keysWithEngines[0].key === DEFAULT_STATE_KEY;\n  }\n  handle(state, event, next) {\n    var _a;\n    if (isPlatformServer(this._platformId)) {\n      return next(state, event);\n    }\n    const matches = actionMatcher(event);\n    const isInitAction = matches(InitState);\n    const isUpdateAction = matches(UpdateState);\n    const isInitOrUpdateAction = isInitAction || isUpdateAction;\n    let hasMigration = false;\n    if (isInitOrUpdateAction) {\n      const addedStates = isUpdateAction && event.addedStates;\n      for (const {\n        key,\n        engine\n      } of this._keysWithEngines) {\n        // We're checking what states have been added by NGXS and if any of these states should be handled by\n        // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added\n        // the `user` state, the storage plugin will be rerun and will do redundant deserialization.\n        // `usesDefaultStateKey` is necessary to check since `event.addedStates` never contains `@@STATE`.\n        if (!this._usesDefaultStateKey && addedStates) {\n          // We support providing keys that can be deeply nested via dot notation, for instance,\n          // `keys: ['myState.myProperty']` is a valid key.\n          // The state name should always go first. The below code checks if the `key` includes dot\n          // notation and extracts the state name out of the key.\n          // Given the `key` is `myState.myProperty`, the `addedStates` will only contain `myState`.\n          const dotNotationIndex = key.indexOf(DOT);\n          const stateName = dotNotationIndex > -1 ? key.slice(0, dotNotationIndex) : key;\n          if (!addedStates.hasOwnProperty(stateName)) {\n            continue;\n          }\n        }\n        const storageKey = getStorageKey(key, this._options);\n        let storedValue = engine.getItem(storageKey);\n        if (storedValue !== 'undefined' && storedValue != null) {\n          try {\n            const newVal = this._options.deserialize(storedValue);\n            storedValue = this._options.afterDeserialize(newVal, key);\n          } catch (_b) {\n            if (NG_DEV_MODE$2) {\n              console.error(`Error ocurred while deserializing the ${storageKey} store value, falling back to empty object, the value obtained from the store: `, storedValue);\n            }\n            storedValue = {};\n          }\n          (_a = this._options.migrations) === null || _a === void 0 ? void 0 : _a.forEach(strategy => {\n            const versionMatch = strategy.version === getValue(storedValue, strategy.versionKey || 'version');\n            const keyMatch = !strategy.key && this._usesDefaultStateKey || strategy.key === key;\n            if (versionMatch && keyMatch) {\n              storedValue = strategy.migrate(storedValue);\n              hasMigration = true;\n            }\n          });\n          if (!this._usesDefaultStateKey) {\n            state = setValue(state, key, storedValue);\n          } else {\n            // The `UpdateState` action is dispatched whenever the feature\n            // state is added. The condition below is satisfied only when\n            // the `UpdateState` action is dispatched. Let's consider two states:\n            // `counter` and `@ngxs/router-plugin` state. When we call `NgxsModule.forRoot()`,\n            // `CounterState` is provided at the root level, while `@ngxs/router-plugin`\n            // is provided as a feature state. Beforehand, the storage plugin may have\n            // stored the value of the counter state as `10`. If `CounterState` implements\n            // the `ngxsOnInit` hook and calls `ctx.setState(999)`, the storage plugin\n            // will rehydrate the entire state when the `RouterState` is registered.\n            // Consequently, the `counter` state will revert back to `10` instead of `999`.\n            if (storedValue && addedStates && Object.keys(addedStates).length > 0) {\n              storedValue = Object.keys(addedStates).reduce((accumulator, addedState) => {\n                // The `storedValue` can be equal to the entire state when the default\n                // state key is used. However, if `addedStates` only contains the `router` value,\n                // we only want to merge the state with the `router` value.\n                // Let's assume that the `storedValue` is an object:\n                // `{ counter: 10, router: {...} }`\n                // This will pick only the `router` object from the `storedValue` and `counter`\n                // state will not be rehydrated unnecessary.\n                if (storedValue.hasOwnProperty(addedState)) {\n                  accumulator[addedState] = storedValue[addedState];\n                }\n                return accumulator;\n              }, {});\n            }\n            state = Object.assign(Object.assign({}, state), storedValue);\n          }\n        }\n      }\n    }\n    return next(state, event).pipe(tap(nextState => {\n      if (isInitOrUpdateAction && !hasMigration) {\n        return;\n      }\n      for (const {\n        key,\n        engine\n      } of this._keysWithEngines) {\n        let storedValue = nextState;\n        const storageKey = getStorageKey(key, this._options);\n        if (key !== DEFAULT_STATE_KEY) {\n          storedValue = getValue(nextState, key);\n        }\n        try {\n          const newStoredValue = this._options.beforeSerialize(storedValue, key);\n          engine.setItem(storageKey, this._options.serialize(newStoredValue));\n        } catch (error) {\n          if (NG_DEV_MODE$2) {\n            if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {\n              console.error(`The ${storageKey} store value exceeds the browser storage quota: `, storedValue);\n            } else {\n              console.error(`Error ocurred while serializing the ${storageKey} store value, value not updated, the value obtained from the store: `, storedValue);\n            }\n          }\n        }\n      }\n    }));\n  }\n}\n/** @nocollapse */\nNgxsStoragePlugin.Éµfac = function NgxsStoragePlugin_Factory(__ngFactoryType__) {\n  return new (__ngFactoryType__ || NgxsStoragePlugin)(i0.ÉµÉµinject(FINAL_NGXS_STORAGE_PLUGIN_OPTIONS), i0.ÉµÉµinject(PLATFORM_ID));\n};\n/** @nocollapse */\nNgxsStoragePlugin.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n  token: NgxsStoragePlugin,\n  factory: NgxsStoragePlugin.Éµfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ÉµsetClassMetadata(NgxsStoragePlugin, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [FINAL_NGXS_STORAGE_PLUGIN_OPTIONS]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\nconst DOT = '.';\nconst NG_DEV_MODE$1 = typeof ngDevMode === 'undefined' || ngDevMode;\nconst USER_OPTIONS = new InjectionToken(NG_DEV_MODE$1 ? 'USER_OPTIONS' : '');\nclass NgxsStoragePluginModule {\n  static forRoot(options) {\n    return {\n      ngModule: NgxsStoragePluginModule,\n      providers: [{\n        provide: NGXS_PLUGINS,\n        useClass: NgxsStoragePlugin,\n        multi: true\n      }, {\n        provide: USER_OPTIONS,\n        useValue: options\n      }, {\n        provide: NGXS_STORAGE_PLUGIN_OPTIONS,\n        useFactory: storageOptionsFactory,\n        deps: [USER_OPTIONS]\n      }, {\n        provide: STORAGE_ENGINE,\n        useFactory: engineFactory,\n        deps: [NGXS_STORAGE_PLUGIN_OPTIONS, PLATFORM_ID]\n      }, {\n        provide: FINAL_NGXS_STORAGE_PLUGIN_OPTIONS,\n        useFactory: createFinalStoragePluginOptions,\n        deps: [Injector, NGXS_STORAGE_PLUGIN_OPTIONS]\n      }]\n    };\n  }\n}\n/** @nocollapse */\nNgxsStoragePluginModule.Éµfac = function NgxsStoragePluginModule_Factory(__ngFactoryType__) {\n  return new (__ngFactoryType__ || NgxsStoragePluginModule)();\n};\n/** @nocollapse */\nNgxsStoragePluginModule.Éµmod = /* @__PURE__ */i0.ÉµÉµdefineNgModule({\n  type: NgxsStoragePluginModule\n});\n/** @nocollapse */\nNgxsStoragePluginModule.Éµinj = /* @__PURE__ */i0.ÉµÉµdefineInjector({});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ÉµsetClassMetadata(NgxsStoragePluginModule, [{\n    type: NgModule\n  }], null, null);\n})();\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\nconst LOCAL_STORAGE_ENGINE = new InjectionToken(NG_DEV_MODE ? 'LOCAL_STORAGE_ENGINE' : '', {\n  providedIn: 'root',\n  factory: () => isPlatformBrowser(inject(PLATFORM_ID)) ? localStorage : null\n});\nconst SESSION_STORAGE_ENGINE = new InjectionToken(NG_DEV_MODE ? 'SESSION_STORAGE_ENGINE' : '', {\n  providedIn: 'root',\n  factory: () => isPlatformBrowser(inject(PLATFORM_ID)) ? sessionStorage : null\n});\n\n/**\n * The public api for consumers of @ngxs/storage-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LOCAL_STORAGE_ENGINE, NGXS_STORAGE_PLUGIN_OPTIONS, NgxsStoragePlugin, NgxsStoragePluginModule, SESSION_STORAGE_ENGINE, STORAGE_ENGINE };\n"],
  "mappings": "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",
  "names": []
}
